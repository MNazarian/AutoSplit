{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "e57d86a3-07d8-498b-b355-d7a1b398a15b",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Loading and preprocessing data...\n",
      "Reading CSV file...\n",
      "Filtering invalid entries and removing label 4...\n",
      "\n",
      "Class distribution before downsampling:\n",
      "label_majority\n",
      "1    3238\n",
      "2    9753\n",
      "3    2106\n",
      "Name: count, dtype: int64\n",
      "\n",
      "Downsampling only class 2 to 70.0% of its original size...\n",
      "\n",
      "Class distribution after downsampling:\n",
      "label_majority\n",
      "1    3238\n",
      "2    6827\n",
      "3    2106\n",
      "Name: count, dtype: int64\n",
      "\n",
      "Calculating features...\n",
      "All important features are present in the dataset.\n",
      "\n",
      "Preparing features and target...\n",
      "Splitting data...\n",
      "Training model...\n",
      "\n",
      "Training with 60 features:\n",
      "1. num_solids\n",
      "2. num_faces\n",
      "3. num_edges\n",
      "4. volume\n",
      "5. surface_area\n",
      "6. x_dim\n",
      "7. y_dim\n",
      "8. z_dim\n",
      "9. num_line_edges\n",
      "10. num_circle_edges\n",
      "11. num_ellipse_edges\n",
      "12. num_hyperbola_edges\n",
      "13. num_parabola_edges\n",
      "14. num_beziercurve_edges\n",
      "15. num_bsplinecurve_edges\n",
      "16. num_othercurve_edges\n",
      "17. num_plane_surfaces\n",
      "18. num_cylinder_surfaces\n",
      "19. num_cone_surfaces\n",
      "20. num_sphere_surfaces\n",
      "21. num_torus_surfaces\n",
      "22. num_bezier_surfaces\n",
      "23. num_bspline_surfaces\n",
      "24. num_revolution_surfaces\n",
      "25. num_extrusion_surfaces\n",
      "26. num_other_surfaces\n",
      "27. num_unique_normals\n",
      "28. wall_thickness\n",
      "29. x_center_mass_relative\n",
      "30. y_center_mass_relative\n",
      "31. z_center_mass_relative\n",
      "32. volume_to_surface_ratio\n",
      "33. edge_to_face_ratio\n",
      "34. average_face_area\n",
      "35. edge_complexity\n",
      "36. surface_complexity\n",
      "37. thickness_complexity\n",
      "38. average_edge_length\n",
      "39. shape_factor\n",
      "40. num_line_edges_ratio\n",
      "41. num_circle_edges_ratio\n",
      "42. num_ellipse_edges_ratio\n",
      "43. num_bsplinecurve_edges_ratio\n",
      "44. num_plane_surfaces_ratio\n",
      "45. num_cylinder_surfaces_ratio\n",
      "46. num_cone_surfaces_ratio\n",
      "47. num_sphere_surfaces_ratio\n",
      "48. num_torus_surfaces_ratio\n",
      "49. num_bspline_surfaces_ratio\n",
      "50. aspect_ratio_xy\n",
      "51. aspect_ratio_xz\n",
      "52. aspect_ratio_yz\n",
      "53. volume_to_xyz\n",
      "54. surface_to_xyz\n",
      "55. center_mass_distance\n",
      "56. log_volume\n",
      "57. log_surface_area\n",
      "58. log_num_faces\n",
      "59. log_num_edges\n",
      "60. overall_complexity\n",
      "Making predictions...\n",
      "\n",
      "Classification Report:\n",
      "              precision    recall  f1-score   support\n",
      "\n",
      "         1.0       0.75      0.74      0.74       648\n",
      "         2.0       0.85      0.85      0.85      1366\n",
      "         3.0       0.80      0.85      0.82       421\n",
      "\n",
      "    accuracy                           0.82      2435\n",
      "   macro avg       0.80      0.81      0.80      2435\n",
      "weighted avg       0.82      0.82      0.82      2435\n",
      "\n"
     ]
    },
    {
     "data": {
      "image/png": "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",
      "text/plain": [
       "<Figure size 1000x800 with 2 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "Model saved as: models/new_model_101.joblib\n",
      "Scaler saved as: models/new_scaler_101.joblib\n",
      "Selected features saved as: models/selected_features_101.joblib\n",
      "\n",
      "Top 20 most important features:\n",
      "                         Feature  Importance\n",
      "38                  shape_factor    0.085678\n",
      "36          thickness_complexity    0.080241\n",
      "27                wall_thickness    0.053853\n",
      "14        num_bsplinecurve_edges    0.033427\n",
      "52                 volume_to_xyz    0.031898\n",
      "42  num_bsplinecurve_edges_ratio    0.029119\n",
      "48    num_bspline_surfaces_ratio    0.028144\n",
      "49               aspect_ratio_xy    0.023305\n",
      "59            overall_complexity    0.023135\n",
      "1                      num_faces    0.022878\n",
      "31       volume_to_surface_ratio    0.021638\n",
      "39          num_line_edges_ratio    0.021222\n",
      "37           average_edge_length    0.021095\n",
      "58                 log_num_edges    0.020427\n",
      "47      num_torus_surfaces_ratio    0.020045\n",
      "50               aspect_ratio_xz    0.019086\n",
      "22          num_bspline_surfaces    0.018890\n",
      "51               aspect_ratio_yz    0.018109\n",
      "2                      num_edges    0.017958\n",
      "57                 log_num_faces    0.017169\n"
     ]
    }
   ],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "from sklearn.model_selection import train_test_split\n",
    "from sklearn.ensemble import RandomForestClassifier\n",
    "from sklearn.metrics import classification_report, confusion_matrix\n",
    "from sklearn.preprocessing import StandardScaler, LabelEncoder\n",
    "from imblearn.over_sampling import SMOTE\n",
    "from imblearn.combine import SMOTETomek\n",
    "from imblearn.pipeline import Pipeline as imbPipeline\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "import joblib\n",
    "from datetime import datetime\n",
    "import os\n",
    "import gc\n",
    "\n",
    "def safe_divide(a, b):\n",
    "    \"\"\"Safely divide two pandas series or numpy arrays.\"\"\"\n",
    "    a = a.astype(np.float64)\n",
    "    b = b.astype(np.float64)\n",
    "    return np.divide(a, b, out=np.zeros_like(a, dtype=np.float64), where=b!=0)\n",
    "\n",
    "def calculate_features(data):\n",
    "    \"\"\"Calculate advanced geometric and topological features from the input data.\"\"\"\n",
    "    data = data.copy()\n",
    "    numeric_columns = data.select_dtypes(include=[np.number]).columns\n",
    "    data[numeric_columns] = data[numeric_columns].astype(np.float64)\n",
    "    \n",
    "    # Basic features\n",
    "    features_to_calculate = [\n",
    "        ('volume_to_surface_ratio', 'volume', 'surface_area'),\n",
    "        ('edge_to_face_ratio', 'num_edges', 'num_faces'),\n",
    "        ('average_face_area', 'surface_area', 'num_faces'),\n",
    "        ('edge_complexity', 'num_edges', 'num_faces'),\n",
    "        ('surface_complexity', 'num_unique_normals', 'num_faces'),\n",
    "        ('thickness_complexity', 'wall_thickness', 'num_faces')\n",
    "    ]\n",
    "    \n",
    "    for new_feat, num, denom in features_to_calculate:\n",
    "        data[new_feat] = safe_divide(data[num].values, data[denom].values)\n",
    "    \n",
    "    # Edge length\n",
    "    data['average_edge_length'] = safe_divide(\n",
    "        data[['x_dim', 'y_dim', 'z_dim']].sum(axis=1).values,\n",
    "        data['num_edges'].values\n",
    "    )\n",
    "    \n",
    "    # Shape factor\n",
    "    volume_pow = np.power(data['volume'].values, 2/3)\n",
    "    data['shape_factor'] = safe_divide(data['surface_area'].values, volume_pow)\n",
    "    \n",
    "    # Ratios - Diese sind wichtig und müssen verwendet werden\n",
    "    edge_columns = ['num_line_edges', 'num_circle_edges', 'num_ellipse_edges', 'num_bsplinecurve_edges']\n",
    "    surface_columns = ['num_plane_surfaces', 'num_cylinder_surfaces', 'num_cone_surfaces', \n",
    "                    'num_sphere_surfaces', 'num_torus_surfaces', 'num_bspline_surfaces']\n",
    "    \n",
    "    # Edge ratios\n",
    "    edge_total = data[edge_columns].sum(axis=1).values\n",
    "    for col in edge_columns:\n",
    "        data[f'{col}_ratio'] = safe_divide(data[col].values, edge_total)\n",
    "    \n",
    "    # Surface ratios\n",
    "    surface_total = data[surface_columns].sum(axis=1).values\n",
    "    for col in surface_columns:\n",
    "        data[f'{col}_ratio'] = safe_divide(data[col].values, surface_total)\n",
    "    \n",
    "    # Aspect ratios - Geometrical features, die verwendet werden müssen\n",
    "    data['aspect_ratio_xy'] = safe_divide(data['x_dim'].values, data['y_dim'].values)\n",
    "    data['aspect_ratio_xz'] = safe_divide(data['x_dim'].values, data['z_dim'].values)\n",
    "    data['aspect_ratio_yz'] = safe_divide(data['y_dim'].values, data['z_dim'].values)\n",
    "    \n",
    "    # Volume ratios\n",
    "    xyz_product = data['x_dim'].values * data['y_dim'].values * data['z_dim'].values\n",
    "    data['volume_to_xyz'] = safe_divide(data['volume'].values, xyz_product)\n",
    "    data['surface_to_xyz'] = safe_divide(data['surface_area'].values, xyz_product)\n",
    "    \n",
    "    # Center mass distance\n",
    "    center_cols = ['x_center_mass_relative', 'y_center_mass_relative', 'z_center_mass_relative']\n",
    "    center_mass_coords = data[center_cols].values - 0.5\n",
    "    data['center_mass_distance'] = np.linalg.norm(center_mass_coords, axis=1)\n",
    "    \n",
    "    # Log transforms - müssen verwendet werden\n",
    "    for col in ['volume', 'surface_area', 'num_faces', 'num_edges']:\n",
    "        min_positive = max(data[col].min(), 1e-10)\n",
    "        data[f'log_{col}'] = np.log1p(data[col].clip(lower=min_positive))\n",
    "    \n",
    "    # Complexity score - wichtige Komplexitätsmaße\n",
    "    complexity_cols = ['edge_complexity', 'surface_complexity', 'thickness_complexity']\n",
    "    data['overall_complexity'] = data[complexity_cols].clip(lower=0).mean(axis=1)\n",
    "    \n",
    "    # Clean up\n",
    "    data = data.replace([np.inf, -np.inf], 0).fillna(0)\n",
    "    \n",
    "    # Verify that important features are present\n",
    "    important_features = [\n",
    "        # Geometrical features\n",
    "        'aspect_ratio_xy', 'aspect_ratio_xz', 'aspect_ratio_yz',\n",
    "        # Complexity measures\n",
    "        'edge_complexity', 'surface_complexity', 'thickness_complexity', 'overall_complexity',\n",
    "        # Log transformations\n",
    "        'log_volume', 'log_surface_area', 'log_num_faces', 'log_num_edges'\n",
    "    ]\n",
    "    \n",
    "    # Add ratio features to the important list\n",
    "    for col in edge_columns:\n",
    "        important_features.append(f'{col}_ratio')\n",
    "    for col in surface_columns:\n",
    "        important_features.append(f'{col}_ratio')\n",
    "    \n",
    "    # Check if all important features are present\n",
    "    missing_features = [f for f in important_features if f not in data.columns]\n",
    "    if missing_features:\n",
    "        print(f\"WARNING: Missing important features: {missing_features}\")\n",
    "    else:\n",
    "        print(\"All important features are present in the dataset.\")\n",
    "    \n",
    "    return data\n",
    "\n",
    "def load_and_preprocess_data(file_path, sample_size=None):\n",
    "    \"\"\"Load and preprocess the data with class-specific downsampling.\"\"\"\n",
    "    print(\"Reading CSV file...\")\n",
    "    data = pd.read_csv(file_path)\n",
    "    \n",
    "    print(\"Filtering invalid entries and removing label 4...\")\n",
    "    mask = (data['volume'] > 0) & (data['surface_area'] > 0) & (data['label_majority'] != 4)\n",
    "    data = data[mask].copy()\n",
    "    \n",
    "    if 'filename' in data.columns:\n",
    "        data = data.drop(columns=['filename'])\n",
    "    \n",
    "    print(\"\\nClass distribution before downsampling:\")\n",
    "    print(data['label_majority'].value_counts().sort_index())\n",
    "    \n",
    "    if sample_size is not None and sample_size < 1.0:\n",
    "        print(f\"\\nDownsampling only class 2 to {sample_size*100}% of its original size...\")\n",
    "        \n",
    "        # Separate the dataset by class\n",
    "        class1_data = data[data['label_majority'] == 1.0]\n",
    "        class2_data = data[data['label_majority'] == 2.0]\n",
    "        class3_data = data[data['label_majority'] == 3.0]\n",
    "        \n",
    "        # Only downsample class 2\n",
    "        downsampled_class2 = class2_data.sample(frac=sample_size, random_state=42)\n",
    "        \n",
    "        # Recombine the datasets\n",
    "        data = pd.concat([class1_data, downsampled_class2, class3_data], ignore_index=True)\n",
    "        \n",
    "        print(\"\\nClass distribution after downsampling:\")\n",
    "        print(data['label_majority'].value_counts().sort_index())\n",
    "    \n",
    "    print(\"\\nCalculating features...\")\n",
    "    data = calculate_features(data)\n",
    "    \n",
    "    return data\n",
    "\n",
    "def train_model(X_train, y_train, random_state=42):\n",
    "    \"\"\"Train the model with custom SMOTE parameters.\"\"\"\n",
    "    n_samples = len(X_train)\n",
    "    \n",
    "    # Print information about the features used for training\n",
    "    print(f\"\\nTraining with {X_train.shape[1]} features:\")\n",
    "    for i, feature in enumerate(X_train.columns, 1):\n",
    "        print(f\"{i}. {feature}\")\n",
    "    \n",
    "    # Adjust k_neighbors based on class sizes\n",
    "    k_neighbors = min(5, n_samples // 100)\n",
    "    \n",
    "    pipeline = imbPipeline([\n",
    "        ('scaler', StandardScaler()),\n",
    "        ('smotetomek', SMOTETomek(\n",
    "            sampling_strategy='auto',\n",
    "            smote=SMOTE(k_neighbors=k_neighbors, random_state=random_state),\n",
    "            random_state=random_state\n",
    "        )),\n",
    "        ('classifier', RandomForestClassifier(\n",
    "            n_estimators=100,\n",
    "            random_state=random_state,\n",
    "            n_jobs=-1  # Use all cores\n",
    "        ))\n",
    "    ])\n",
    "    \n",
    "    pipeline.fit(X_train, y_train)\n",
    "    return pipeline\n",
    "\n",
    "def save_model_components(pipeline, le, X_train, version=\"11\"):\n",
    "    \"\"\"\n",
    "    Save the trained model components separately with specified version number:\n",
    "    - Random Forest model\n",
    "    - Scaler\n",
    "    - Selected features\n",
    "    \"\"\"\n",
    "    # Create directory if it doesn't exist\n",
    "    os.makedirs('models', exist_ok=True)\n",
    "    \n",
    "    # Extract components from pipeline\n",
    "    rf_model = pipeline.named_steps['classifier']\n",
    "    scaler = pipeline.named_steps['scaler']\n",
    "    \n",
    "    # Get feature names\n",
    "    selected_features = list(X_train.columns)\n",
    "    \n",
    "    # Prepare filenames with specified version\n",
    "    model_filename = f'models/new_model_{version}.joblib'\n",
    "    scaler_filename = f'models/new_scaler_{version}.joblib'\n",
    "    features_filename = f'models/selected_features_{version}.joblib'\n",
    "    \n",
    "    # Save components\n",
    "    joblib.dump(rf_model, model_filename)\n",
    "    joblib.dump(scaler, scaler_filename)\n",
    "    joblib.dump(selected_features, features_filename)\n",
    "    \n",
    "    print(f\"\\nModel saved as: {model_filename}\")\n",
    "    print(f\"Scaler saved as: {scaler_filename}\")\n",
    "    print(f\"Selected features saved as: {features_filename}\")\n",
    "    \n",
    "    # Feature importance analysis\n",
    "    feature_importances = rf_model.feature_importances_\n",
    "    features_df = pd.DataFrame({\n",
    "        'Feature': selected_features,\n",
    "        'Importance': feature_importances\n",
    "    }).sort_values('Importance', ascending=False)\n",
    "    \n",
    "    print(\"\\nTop 20 most important features:\")\n",
    "    print(features_df.head(20))\n",
    "\n",
    "def main():\n",
    "    # Set your file path here\n",
    "    file_path = r\"C:\\Users\\meh91075\\Downloads\\features_newWallthickness_16092024.csv\"\n",
    "    \n",
    "    # Optional: Use a smaller sample size for development/testing\n",
    "    # Set to None or 1.0 to use full dataset\n",
    "    SAMPLE_SIZE = 0.7  # Use 50% of data (only for class 2)\n",
    "    \n",
    "    print(\"Loading and preprocessing data...\")\n",
    "    df = load_and_preprocess_data(file_path, sample_size=SAMPLE_SIZE)\n",
    "    \n",
    "    print(\"\\nPreparing features and target...\")\n",
    "    X = df.drop(columns=['label_majority'])\n",
    "    y = df['label_majority']\n",
    "    \n",
    "    # Clean up memory\n",
    "    del df\n",
    "    gc.collect()\n",
    "    \n",
    "    le = LabelEncoder()\n",
    "    y_encoded = le.fit_transform(y)\n",
    "    \n",
    "    print(\"Splitting data...\")\n",
    "    X_train, X_test, y_train, y_test = train_test_split(\n",
    "        X, y_encoded, test_size=0.2, random_state=42, stratify=y_encoded\n",
    "    )\n",
    "    \n",
    "    # Clean up memory\n",
    "    del X\n",
    "    gc.collect()\n",
    "    \n",
    "    print(\"Training model...\")\n",
    "    pipeline = train_model(X_train, y_train)\n",
    "    \n",
    "    print(\"Making predictions...\")\n",
    "    y_pred = pipeline.predict(X_test)\n",
    "    \n",
    "    y_test_original = le.inverse_transform(y_test)\n",
    "    y_pred_original = le.inverse_transform(y_pred)\n",
    "    \n",
    "    print(\"\\nClassification Report:\")\n",
    "    print(classification_report(y_test_original, y_pred_original))\n",
    "    \n",
    "    cm = confusion_matrix(y_test_original, y_pred_original)\n",
    "    plt.figure(figsize=(10, 8))\n",
    "    sns.heatmap(cm, annot=True, fmt='d', cmap='Blues')\n",
    "    plt.title('Confusion Matrix')\n",
    "    plt.xlabel('Predicted Label')\n",
    "    plt.ylabel('True Label')\n",
    "    plt.show()\n",
    "    \n",
    "    # Save model components separately with version number\n",
    "    save_model_components(pipeline, le, X_train, version=\"101\")\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "pyoccenv",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.14"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
